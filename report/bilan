
Se concentrer sur :

 - La demarche qu'on a eue
 - Les etapes de conception du proco
 - Notre implementation

============================================================================================
I - Introduction
============================================================================================

Le but de notre projet est de creer un processeur ARM
On part d'un cahier des charges : la doc ARM,
decrivant l'architecture du processeur a concevoir
Il faut construire ce processeur.

CDC -->  Boite noire  --> Processeur

CDC :
 - Processeur pipelined
 - Pipeline asynchrone
 - *Respect du jeu d'instructions*

II - La demarche de conception

Detaillons la boite noire
1 - Design              crayon, papier
2 - Modelisation        langage vhdl
2 - Simulation, Test    ghdl, gtkwave, plateforme test.
3 - Placement & Routage druc, cougar, lvx, tas, s2r.
4 - Fonderie            Envoi du masque a un fondeur...

============================================================================================
III - Design
============================================================================================

------------------ Design general ----------------------------------------------------------

ETUDIONS PLUS EN DETAIL LE CDC :

Regops :
lecture instruction,
decodage instruction,
preparation des operandes
execution de l'operation de calcul,
ecriture dans les registres

Branchements :    
lecture instruction,
decodage instruction,
*annulation des instruction qui suivent dans le pipe*
preparation des operandes               (registre de base)
execution de l'operation de calcul      (@ de branchement)
ecriture dans les registres             (R15)

Acces memoires :
lecture instruction,
decodage instruction,
preparation des operandes               (registre de base, registre source)
execution de l'operation de calcul,     (calcul @mem)
ecriture dans les registres             (registre de base (wbk), registre dest)

Acces memoires multiples :
lecture instruction,
decodage instruction,
preparation des operandes               (registre de base, registre source)
gestion de la boucle d'envoi
execution de l'operation de calcul,     (calcul @mem)
ecriture dans les registres             (registre de base (wbk), registre dest)

=> Il faut pouvoir effectuer toutes les etapes de chaque instruction avec le minimum
de materiel possible
=> D'ou le decoupage en etages suivant : I, D, E, M

[ Schema a la Pirouz ]

-----------------------------------------------------------------------------------------------
------------------ A - Design de EXE ----------------------------------------------------------
-----------------------------------------------------------------------------------------------

Quels sont tous les calculs possibles que EXE devra pouvoir realiser?
=> Il faut que EXE puisse realiser tous les calculs necessaires a l'execution
des instruction ARM avec le minimum de materiel possible.

Dans le jeu d'instruction on a :
  - les regops
  - les branch
  - les acces memoire

Mais les branch et les acces memoire ont besoin de faire des additions seulement,
et parmi les regops il existe une instruction d'addition, donc si EXE peut effectuer
les calculs necessaire aux regops, elle pourra aussi effectuer les calculs necessaires
aux branch et transferts memoire. Reduisons donc le probleme aux regops.

Tableau :
=> Il faut trouver une reecriture standardisee des calculs a effectuer,
pour decomposer notre ensemble de calcul en un sous-ensemble de calculs elementaires,
et ainsi reduire au maximum le materiel a implemnter.

REGOP          CALCUL A EFFECTUER       REECRITURE STANDARDISEE

=> On voit que les calculs elementaires sont :
ADD, AND, OR, XOR, inversion des entrees prealables, ajout d'un 1
De plus, d'apres la doc ARM, l'operande 2 peut subir un shift (lsl, lsr, asr, ror, rrx)
Enfin, a chaque operation les flags de sortie doivent etre calcules.

Avec ces deux points, une implementation de EXE est :
[ Schema de EXE ]

------------------ 2 - Design de l'ALU --------------------------------------------------------

L'ALU doit pouvoir effectuer les operation ADD, AND, OR et XOR sur deux entrees,
de plus pour l'addition elle doit pouvoir prendre en compte une retenue en entree (l'ajout d'un 1).
[ Symbole de l'ALU vue externe ]

Notre implementation de l'ALU est la suivante :
[ Schema de l'ALU vue interne ]
L'ALU effectue de toutes manieres les 4 operation qu'elle peut faire, mais choisit de mettre en sortie
de resultat de l'operation qu'on lui a demande.
Pour le calcul des flags, le bloc (=0) effectue un simple and entre tous les bits du resultat,
le bloc (<0) verifie si le msb est a 1, et pour le bloc overflow, on regarde la sortie du ADD qui est sur 35 bits
et on verifie si le 35eme bit est a 1.

------------------ 3 Design du Shifter --------------------------------------------------------

Tout comme pour l'ALU, on peut demander plusieurs choses au shifter, les operations de shift possible sont
LSL (Logical Shift Left), LSR, ASR, ROR, RRX.
Donc comme pour l'ALU, le shifter effectue tous les shifts possible et choisit le resultat demande :

[ Schema 1 du shifter ]

Puis pour realiser un LSL, on observe chaque bit de la shift value : Si le bit 0 est a 1, on decale l'operande
de 1, puis si le bit 1 est a 1, on decale l'operande de 2 sinon on ne fait rien, si le bit n est a 1,
on decale l'operande de 2n. Le decalage final est donc : somme des 2^k, k etant les poids des bits a 1. 
= shift value
Effectuer un decalage a gauche de n revient a enlever les n bits de poids forts et concatener au reste
n zeros.
Une logique similaire est appliquee pour implementer les LSR, ASR, ROR et RRX

------------------ 4 - Ajouts sur EXE ---------------------------------------------------------

Le flag C
D'apres la doc ARM, le flag C en sortie d'une operation peut etre la carry de sortie de l'addition
pour les regops arithmetiques ou la carry de sortie du shift pour les regops logiques.
On place donc un multiplexer sur le flags C pour effectuer le bon choix, et on deduit le type
de regop (arith ou logique) en regardant si l'operation demandee est un ADD ou un AND/OR/XOR.

[ Schema du morceau carry de EXE ]

Le pre-index / post-index
Lors d'un acces memoire, le jeu ARM offre la possibilite de choisir si l'adresse prise en compte
pour un acces memoire est l'adresse de base ou l'adresse de base + offset.
Dans EXE, pour un acces memoire, l'adresse de base sera l'operande 2, et l'adresse base + offset
sera le resultat de l'ALU (qui effectue un ADD), on choisit donc entre ces deux signaux
pour implementer le pre-index/post-index

[ Schema de la partie pre-index de EXE ]


------------------ 5 - Communication avec les autres etages -----------------------------------

handling de la FIFO,


-----------------------------------------------------------------------------------------------
------------------ C - Design de DECOD --------------------------------------------------------
-----------------------------------------------------------------------------------------------

Pour chaque instruction, hormis quelques spécificités dues aux branchements
et transferts multiples, DECOD doit faire 5 choses :
  - Envoyer l'adresse de l'instruction (valeur de PC) vers IFC.
  - Récupérer l'instruction de IFC.
  - Décoder l'instruction (quel opération effectuer, quelles opérandes utiliser)
  - Vérifier si la condition d'exécution est remplie (exécution conditionnelle)
  - Lire les opérandes à utiliser sur le banc de registres.
  - Envoyer les opérandes lues et le type d'opération à effectuer vers EXE.
  - Passer à l'instruction suivante (incrémenter PC)

Dans un premier temps, nous modéliserons le comportement général de DECOD,
puis nous apporterons des amélioration au fur et à mesure pour implémenter les branchements,
les branchements avec link puis les transferts multiples. Nous avons donc choisi une approche
"instruction par instruction" pour la modélisation de DECOD.

------------------ 1 - Design général ---------------------------------------------------------

Le premier type d'instruction à implémenter sont les regops, elles ne font rien de spécial
à DECOD donc c'est adapté de commence par elles pour implémenter le comportement général de DECOD.
Dans DECOD nous placerons le bang de registres (REG), nous verrons donc un par un les choses
à implémenter dans DECOD et dans REG.

-- Envoi du PC vers IFC ---------------------

Nous plaçons dans REG la sortie reg_pc qui donne à DEC la valeur de PC à chaque instant,
puis DEC transmet cette valeur à IFC sur la sortie dec_pc via une FIFO (dec2if).

[ Schema DEC 1 ]

-- Récupération de l'instruction depuis IFC -

Il y a encore communication entre deux étages, donc nous avons encore une FIFO (if2dec)
mais comme la convention veut que la FIFO soit à l'étage émetteur, elle sera dans IFC,
donc dans DEC nous récupérons simplement l'instruction via une entrée if_ir[32bits].

[ Schema DEC 2 ]

-- Décodage de l'instruction ----------------

--------- Decodage du type d'instruction -----------------
Il s'agit ici de lire, à partir des 32 bits de if_ir, quelle opération
doit être effectuée et sur quelles opérandes.

La première chose à décoder est le type d'instruction. Selon le détail du format des
instructions en Figure \ref{format_instr}, si on ne considère que les instruction :
  - Data processing
  - Multiply
  - Single Data Swap
  - Single Data Transfert
  - Block Data Transfert
  - Branch

Le premier critère est que les bits 27 à 25 valent :
  - 00X    pour les regops, les multiply et swap
  - 01X    pour les single data transfert
  - 100    pour les multiple transferts
  - 101    pour les branch

Ensuite, pour distinguer les regops, multiply et swap, le deuxième critère est que :
  - Pour les mult, les bits 25 à 23 valent 000 et les bits 7 à 4 valent 1001
  - Pour les swap, les bits 25 à 23 valent 101 et les bits 7 à 4 valent 1001
On pourrait penser a priori que les regops pourraient, dans leur opérande 2,
avoir leurs bits 7 à 4 égaux à 1001 mais dans le détail de l'opérande 2 et du shift,
on observe que si le bit 4 vaut 1, le bit 7 vaut forcément 0 donc cette combinaison est impossible,
il n'y a donc pas de conflit potentiel.

code : les xxx_t

--------- Decodage de l'instruction -----------------

Maintenant qu'on connait de type d'instruction, il faut déterminer à quelle instruction
on a affaire précisément.

Pour les regops, c'est immédiat : les bits 24 à 21 de if_ir donnent directement l'opcode,
d'ou. (Pour les trans (Single Data Transfert), il suffit de lire les bits 20 et 22 qui donnent
respectivement le sens d'accès (lecture/écriture) et la taille de la données accédée (mot/octet)).

code : les xxx_i

La figure ... résume ce qu'il a dans DECOD pour l'instant.

[ Figure ]

--------- Verification de la condition d'execution --

Le jeu ARM comporte une fonctionnalité d'execution conditionnelle,
une instruction n'est lancée seulement si la condition sur les flags imposée
par l'instruction est remplie. Il suffit de lire if_ir pour connaître la condition
et les flags pour savoir si elle est remplie.

--------- Lecture des opérandes ---------------------

L'exécution d'une instruction nécéssite de récupérer la valeur de certains registres pour
effectuer une opération dessus (ce sera EXE qui la fera). DECOD doit se charger
de lire les registres nécéssaires depuis le banc de registres pour fournir leurs valeurs à EXE.

Pour cela, nous placerons 3 ports de lecture dans REG (3 car les instruction ont besoin de
connaître au maximum les valeurs de 3 registres). La lecture se fera au sein d'un même cycle d'horloge
car tout ce que fait DECOD doit se faire en un cycle.

Ensuite, DECOD doit déterminer quels registres lire à chaque fois.
Dans la documentation ARM, les registres à lire potentiellement sont Rd, Rn, Rm et Rs,
nous assignerons:
  - Le port de lecture 1 de REG     à Rn,
  - Le port 2 à Rm
  - Le port 3 à Rd et Rs
Aucune instruction ne lit Rd et Rs en même temps, donc il n'y aura pas de conflit sur le port 3.
Puis le numéro des registres Rn, Rm, Rd et Rs est données dans if_ir, encore selon la doc ARM :
  - Rd est donné dans les bits 15 à 12 (sauf pour le mult ou c'est de 19 à 15)
  - Rn -> if_ir(19:16) sauf pour les mult où c'est if_ir(15:12)
  - Rm -> if_ir(3:0)
  - Rs -> if_ir(11:8)
Il suffit de récupérer ces champs et de les donner en adresse à REG pour obtenir nos valeurs de registres :

code : radr

--------- Envoi de l'opération à EXE ----------------

Une fois les opérandes lues, il s'agit de les envoyer vers EXE ainsi que les détails
sur l'opération à effectuer, c'est à dire les signaux :
  - alu_dest
  - op1
  - op2
  - alu_cmd
  - alu_cy
  - comp_op1
  - comp_op2
  - shift_lsl
  - shift_lsr
  - shift_asr
  - shift_ror
  - shift_rrx
  - shift_val

Nous nous concentrerons sur le cas des regops :

alu_dest sera Rd, c'est à dire if_ir(15:12).
op1 sera la valeur de Rn, (port 1 de REG)
op2 sera soit la valeur de Rm (port 2 de REG), soit un immediat (if_ir(7 downto 0) zero-extended)

Quant à alu_cmd, alu_cy, comp_op1 et comp_op2, leur valeur dépend de l'instruction en question,
la Figure ... détaille leurs valeurs.

[ Tableau ]

Enfin, il faut spécifier quel décalage appliquer à l'opérande 2.
Le type de décalage est donné par if_ir(6:5) mais dans le cas des rotations,
il faut distinguer ROR et RRX dans le cas if_ir(6:5) = "11" :
On a un ROR si l'opérande 2 est un immédiat ou si c'est un register mais que le shift amount n'est pas nul.

---------- Ecriture du résultat dans le banc de registre (write back) --

Une fois que l'instruction est envoyée, les étages suivant la reçoivent et produisent un résultat.
Ce résultat doit ensuite être stocké dans le banc de registre et pour cela, nous ajoutons dans DEC
les entrées res (le résultat produit), dest (le numéro du registre où écrire) et wb (s'il faut écrire
ou non) pour le résultat de EXE, le résultat de MEM et les flags :

 - exe_res
 - exe_dest
 - exe_wb

 - exe_c
 - exe_n
 - exe_z
 - exe_v
 - exe_flag_wb

 - mem_res
 - mem_dest
 - mem_wb

Par conséquent, le banc de registres prendra deux ports d'écriture (pour EXE et pour MEM)
et un port pour les flags. Contrairement à la lecture, l'écriture dans REG se fera sur front d'horloge.

--------- Mecanisme d'invalidation ------------------------------------

Pour que l'étage DECOD soit fonctionnel, il reste à gérer le problème des dépendances.
Pour cela, nous utiliserons un mécanisme d'invalidation des registres et flags :
lorsqu'une instruction compte écrire dans un registre, elle l'invalide dans DECOD
et le revalide lorsqu'elle écrit le résultat dans REG, et une instruction ne se lance
seulement si tous les registres et flags qu'elle lit sont valides, autrement elle reste gelée dans DEC.

---- Validite du predicat -----------
Le prédicat est valide si et seulement si tous les flags qu'elle vérifie sont valides,
et les flags vérifiés ou non dépendent de la condition d'execution elle-même.
Le Tableau ... détaille les flags utilisés en fonction de la condition d'execution
et justifie le code qui assigne condv.

[ Tableau ] Regop  |  Condition sur les flags  | c, z, n sont utilises  | v est utilise

[ code de condv ]

---- Validite des operandes ---------

Une fois que le prédicat est valide, l'instruction peut être lancée seulement si toutes les opérandes
qu'elle lit sont valides, et là encore les opérandes lues dépendent du type d'instruction.
Pour les regops, Rn est toujours lu, Rm est lu si l'opérande 2 est de type registre,
Rs est lu si le décalage est de type registre. D'où le code suivant :
(pour l'instant seules les regops sont implémentées)

[ code de operv ]

---- Invalidation des registres -----

Les registres invalidés sont les registres dans lesquels l'instruction écrit.
Pour les regops, c'est Rd (sauf pour 4 instructions, qui ne font qu'écrire les flags).
D'où le code suivant :

[ code de inval_exe et inval_exe_adr ]

---- Invalidation des flags ---------

Les flags à invalider sont les flags écrits, et pour les regops les flags écrits
sont c, z, n pour les instructions logiques ou c, z, n, v pour les instructions arithmétiques.
Les flags sont écrits seulement si le bit S (if_ir(20)) est à 1, à l'exception des instructions
TST, TEQ, CMP Et CMN qui considèrent automatiquement que S est à 1.

[ code de inval_czn et inval_ovr ]

---- Gestion de la validite dans REG-

Dans le banc de registres, la validité d'un registre/flag est gérée de la manière suivante :
Pour chaque registre/flag correspond une commande inval et write pour l'invalider ou l'écrire
(et donc la revalider), la valeur de ces deux commandes déterminera la validité du registre
au cycle suivant, comme indiqué dans le Tableau ... .

[ Tableau ] inval  |  write  |  valid

Lorsque inval et write sont tous les deux à 1, une instruction écrit son résultat
dans le registre mais cela ne change rien au fait que l'instruction en cours écrira dedans
et que les instructions suivantes devront attendre si elles veulent le lire, donc on
invalide quand même le registre.
Un problème est que si le registre actuel lit et écrit le même registre, comme
dans l'exemple suivant :

[ code ] mov R4, #0; add R4, R4, #1

Au cycle où add est dans DEC (et mov dans EXE), R4 sera écrit et invalidé sauf que notre
implémentation fait prévaloir l'invalidation donc R4 sera invalide au cycle suivant,
add restera donc indéfiniment gelée dans DEC,
attendant une revalidation qu'elle ne verra jamais car elle aura été écrasée par l'invalidation de add.
Pour cela, nous avons ajouté pour chaque port de lecture un flag wbk passant à 1 pendant un cycle
si le registre en question a été écrit, ainsi on considère un registre valide si son flag valid est à 1
où si son flag wbk est à 1.
  
-- Mécanisme de gestion des états de DECOD ----------------

Jusqu'alors, nous avons vu DECOD dans son fonctionnement normal : une instruction arrive de IFETCH,
est décodés puis envoyés, mais DECOD peut se trouver dans des situations différentes, par exemple :
DECOD pourra être en train de geler en attendant la validation d'un registre,
lorsque nous implémenterons les branchements DECOD pourra être dans un état spécial où le PC ne s'incrémente
plus et devra attendre la validité du registre R15 pour continuer, pour les transferts multiples
DECOD devra entrer dans une boucle de lancement d'instruction de transferts simples...
=> A chaque cycle, DECOD sera dans une certaine situation et devra adopter un certain comportement en conséquence,
et la manière canonique de gérer la multiplicité de ces situations, de ces états, est via une machine à états.

 - L'état "normal" de fonctionnement, que nous avons vu jusqu'alors, sera appelé l'état RUN.
 - Ensuite, un deuxième état FETCH est associé au cas où PC n'est pas valide
   (cela arrive après un branch ou au démarrage) car dans ce cas le comportement de DECOD doit changer,
   le PC ne s'incrémente plus et n'est plus envoyé vers IFETCH.

Puis pour gérer le gel, lors d'un cycle de gel la machine reste à l'état RUN mais ne lance pas l'instruction
vers EXE. Ainsi l'instruction reste dans DECOD, en attendant la validité des opérandes.
Cela aboutit à une première machine à états en Figure ... .

[ MAE partielle ]

Pour l'instant ces deux états suffisent à l'implémentation des regops, mais par la suite,
nous ajouterons les états suivants :
 - l'état BRANCH dans lequel DECOD annulera l'execution des instruction déja chargées dans le pipeline
   et lancera le calcul du nouveau PC.
   Comme un nouveau PC est calculé, il a été invalidé donc on retourne à l'état FETCH où on attendra
   la revalidation de PC.
 - L'état LINK dans lequel DECOD lancera et attendra le calcul de l'adresse de retour avant de branch
   Une fois que le LINK est fait on peut brancher, donc on passera à l'état BRANCH.
 - L'été MTRANS dans lequel DECOD restera en boucle à envoyer toutes les instructions de transfert simples
   contenues dans le transfert multiple.
   Une fois qu'on a terminé on retourne simplement à l'état normal RUN, sauf si le transfert multiple a
   modifié R15 auquel cas on passe à l'état BRANCH.

Tous ces éléments aboutissent à la machine a états en Figure ... .

[ MAE finale ]
  incrementation de pc


-- Bilan de DECOD -----------------------------------------

Tous ce que nous avons vu sur la modélisation de DECOD mène au schema en Figure ... .

[ Schema de DECOD ]

-------------------------------------------------------------------------------------------------------------------
bilan :
ameliorations :
 - FIFO a plusieurs cases
 - probleme D - E - M
   ldw R4, ...
   add R4, R10, R11
   add R4, R4, #1

ouverture :
 - Faudrait ensuite implementer
   les bypass
   la gestion de la vmem,
   les interruptions
   ...pour faire tourner Linux dessus

-------------------------------------------------------------------------------------------------------------------
Le moteur : PC qui s'incremente de 4 a chaque cycle

Decodage combinatoire
  Type de l'instruction
  Les regops
    op2 immediate
    op2 register
    shift immediate
    shift register
Lecture des operandes
  REG :
  Trois ports de lecture on-cycle
  Comment decider quels registres lire selon l'instruction actuelle
Gestion des dependances : Mecanisme d'invalidation des registres
  Le principe
  Invalidation dans DECOD
  Revalidation au writeback
Gestion des differents etats de DECOD : FSM
  DEC fera des choses differentes en fonction de
  si l'adresse PC est valide ou non,
  si on est en plein branchement et qu'on doit annuler les instruction qui suivent,
  si on est en plein transfert multiple,
  ou si on est tout simplement en etat "normal" et que les instructions defilent.
  => Pour gerer cela, la methode adequate est la MAE
  FETCH : L'adresse pointee par PC n'est pas valide, on attend qu'elle le soit.
  Ca arrive quand un branchement est dans EXE et que l'adresse de branchement
  est en train d'etre calculee, ou alors au demarrage de la machine.
  RUN : C'est l'etat "normal" de DEC, rien de special, les instructions arrivent,
  sont decodees puis envoyees dans EXE.

