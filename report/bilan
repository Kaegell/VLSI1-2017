
Se concentrer sur :

 - La demarche qu'on a eue
 - Les etapes de conception du proco
 - Notre implementation

============================================================================================
I - Introduction
============================================================================================

Le but de notre projet est de creer un processeur ARM
On part d'un cahier des charges : la doc ARM,
decrivant l'architecture du processeur a concevoir
Il faut construire ce processeur.

CDC -->  Boite noire  --> Processeur

CDC :
 - Processeur pipelined
 - Pipeline asynchrone
 - *Respect du jeu d'instructions*

II - La demarche de conception

Detaillons la boite noire
1 - Design              crayon, papier
2 - Modelisation        langage vhdl
2 - Simulation, Test    ghdl, gtkwave, plateforme test.
3 - Placement & Routage druc, cougar, lvx, tas, s2r.
4 - Fonderie            Envoi du masque a un fondeur...

============================================================================================
III - Design
============================================================================================

------------------ Design general ----------------------------------------------------------

ETUDIONS PLUS EN DETAIL LE CDC :

Regops :
lecture instruction,
decodage instruction,
preparation des operandes
execution de l'operation de calcul,
ecriture dans les registres

Branchements :    
lecture instruction,
decodage instruction,
*annulation des instruction qui suivent dans le pipe*
preparation des operandes               (registre de base)
execution de l'operation de calcul      (@ de branchement)
ecriture dans les registres             (R15)

Acces memoires :
lecture instruction,
decodage instruction,
preparation des operandes               (registre de base, registre source)
execution de l'operation de calcul,     (calcul @mem)
ecriture dans les registres             (registre de base (wbk), registre dest)

Acces memoires multiples :
lecture instruction,
decodage instruction,
preparation des operandes               (registre de base, registre source)
gestion de la boucle d'envoi
execution de l'operation de calcul,     (calcul @mem)
ecriture dans les registres             (registre de base (wbk), registre dest)

=> Il faut pouvoir effectuer toutes les etapes de chaque instruction avec le minimum
de materiel possible
=> D'ou le decoupage en etages suivant : I, D, E, M

[ Schema a la Pirouz ]

-----------------------------------------------------------------------------------------------
------------------ A - Design de EXE ----------------------------------------------------------
-----------------------------------------------------------------------------------------------

Quels sont tous les calculs possibles que EXE devra pouvoir realiser?
=> Il faut que EXE puisse realiser tous les calculs necessaires a l'execution
des instruction ARM avec le minimum de materiel possible.

Dans le jeu d'instruction on a :
  - les regops
  - les branch
  - les acces memoire

Mais les branch et les acces memoire ont besoin de faire des additions seulement,
et parmi les regops il existe une instruction d'addition, donc si EXE peut effectuer
les calculs necessaire aux regops, elle pourra aussi effectuer les calculs necessaires
aux branch et transferts memoire. Reduisons donc le probleme aux regops.

Tableau :
=> Il faut trouver une reecriture standardisee des calculs a effectuer,
pour decomposer notre ensemble de calcul en un sous-ensemble de calculs elementaires,
et ainsi reduire au maximum le materiel a implemnter.

REGOP          CALCUL A EFFECTUER       REECRITURE STANDARDISEE

=> On voit que les calculs elementaires sont :
ADD, AND, OR, XOR, inversion des entrees prealables, ajout d'un 1
De plus, d'apres la doc ARM, l'operande 2 peut subir un shift (lsl, lsr, asr, ror, rrx)
Enfin, a chaque operation les flags de sortie doivent etre calcules.

Avec ces deux points, une implementation de EXE est :
[ Schema de EXE ]

------------------ 2 - Design de l'ALU --------------------------------------------------------

L'ALU doit pouvoir effectuer les operation ADD, AND, OR et XOR sur deux entrees,
de plus pour l'addition elle doit pouvoir prendre en compte une retenue en entree (l'ajout d'un 1).
[ Symbole de l'ALU vue externe ]

Notre implementation de l'ALU est la suivante :
[ Schema de l'ALU vue interne ]
L'ALU effectue de toutes manieres les 4 operation qu'elle peut faire, mais choisit de mettre en sortie
de resultat de l'operation qu'on lui a demande.
Pour le calcul des flags, le bloc (=0) effectue un simple and entre tous les bits du resultat,
le bloc (<0) verifie si le msb est a 1, et pour le bloc overflow, on regarde la sortie du ADD qui est sur 35 bits
et on verifie si le 35eme bit est a 1.

------------------ 3 Design du Shifter --------------------------------------------------------

Tout comme pour l'ALU, on peut demander plusieurs choses au shifter, les operations de shift possible sont
LSL (Logical Shift Left), LSR, ASR, ROR, RRX.
Donc comme pour l'ALU, le shifter effectue tous les shifts possible et choisit le resultat demande :

[ Schema 1 du shifter ]

Puis pour realiser un LSL, on observe chaque bit de la shift value : Si le bit 0 est a 1, on decale l'operande
de 1, puis si le bit 1 est a 1, on decale l'operande de 2 sinon on ne fait rien, si le bit n est a 1,
on decale l'operande de 2n. Le decalage final est donc : somme des 2^k, k etant les poids des bits a 1. 
= shift value
Effectuer un decalage a gauche de n revient a enlever les n bits de poids forts et concatener au reste
n zeros.
Une logique similaire est appliquee pour implementer les LSR, ASR, ROR et RRX

------------------ 4 - Ajouts sur EXE ---------------------------------------------------------

Le flag C
D'apres la doc ARM, le flag C en sortie d'une operation peut etre la carry de sortie de l'addition
pour les regops arithmetiques ou la carry de sortie du shift pour les regops logiques.
On place donc un multiplexer sur le flags C pour effectuer le bon choix, et on deduit le type
de regop (arith ou logique) en regardant si l'operation demandee est un ADD ou un AND/OR/XOR.

[ Schema du morceau carry de EXE ]

Le pre-index / post-index
Lors d'un acces memoire, le jeu ARM offre la possibilite de choisir si l'adresse prise en compte
pour un acces memoire est l'adresse de base ou l'adresse de base + offset.
Dans EXE, pour un acces memoire, l'adresse de base sera l'operande 2, et l'adresse base + offset
sera le resultat de l'ALU (qui effectue un ADD), on choisit donc entre ces deux signaux
pour implementer le pre-index/post-index

[ Schema de la partie pre-index de EXE ]


------------------ 5 - Communication avec les autres etages -----------------------------------

handling de la FIFO,


-----------------------------------------------------------------------------------------------
------------------ C - Design de DECOD --------------------------------------------------------
-----------------------------------------------------------------------------------------------

Pour chaque instruction, hormis quelques spécificités dues aux branchements
et transferts multiples, DECOD doit faire 5 choses :
  - Envoyer l'adresse de l'instruction (valeur de PC) vers IFC.
  - Récupérer l'instruction de IFC.
  - Décoder l'instruction (quel opération effectuer, quelles opérandes utiliser)
  - Vérifier si la condition d'exécution est remplie (exécution conditionnelle)
  - Lire les opérandes à utiliser sur le banc de registres.
  - Envoyer les opérandes lues et le type d'opération à effectuer vers EXE.
  - Passer à l'instruction suivante (incrémenter PC)

Dans un premier temps, nous modéliserons le comportement général de DECOD,
puis nous apporterons des amélioration au fur et à mesure pour implémenter les branchements,
les branchements avec link puis les transferts multiples. Nous avons donc choisi une approche
"instruction par instruction" pour la modélisation de DECOD.

------------------ 1 - Design général ---------------------------------------------------------

Le premier type d'instruction à implémenter sont les regops, elles ne font rien de spécial
à DECOD donc c'est adapté de commence par elles pour implémenter le comportement général de DECOD.
Dans DECOD nous placerons le bang de registres (REG), nous verrons donc un par un les choses
à implémenter dans DECOD et dans REG.

-- Envoi du PC vers IFC ---------------------

Nous plaçons dans REG la sortie reg_pc qui donne à DEC la valeur de PC à chaque instant,
puis DEC transmet cette valeur à IFC sur la sortie dec_pc via une FIFO (dec2if).

[ Schema DEC 1 ]

-- Récupération de l'instruction depuis IFC -

Il y a encore communication entre deux étages, donc nous avons encore une FIFO (if2dec)
mais comme la convention veut que la FIFO soit à l'étage émetteur, elle sera dans IFC,
donc dans DEC nous récupérons simplement l'instruction via une entrée if_ir[32bits].

[ Schema DEC 2 ]

-- Décodage de l'instruction ----------------

--------- Decodage du type d'instruction -----------------
Il s'agit ici de lire, à partir des 32 bits de if_ir, quelle opération
doit être effectuée et sur quelles opérandes.

La première chose à décoder est le type d'instruction. Selon le détail du format des
instructions en Figure \ref{format_instr}, si on ne considère que les instruction :
  - Data processing
  - Multiply
  - Single Data Swap
  - Single Data Transfert
  - Block Data Transfert
  - Branch

Le premier critère est que les bits 27 à 25 valent :
  - 00X    pour les regops, les multiply et swap
  - 01X    pour les single data transfert
  - 100    pour les multiple transferts
  - 101    pour les branch

Ensuite, pour distinguer les regops, multiply et swap, le deuxième critère est que :
  - Pour les mult, les bits 25 à 23 valent 000 et les bits 7 à 4 valent 1001
  - Pour les swap, les bits 25 à 23 valent 101 et les bits 7 à 4 valent 1001
On pourrait penser a priori que les regops pourraient, dans leur opérande 2,
avoir leurs bits 7 à 4 égaux à 1001 mais dans le détail de l'opérande 2 et du shift,
on observe que si le bit 4 vaut 1, le bit 7 vaut forcément 0 donc cette combinaison est impossible,
il n'y a donc pas de conflit potentiel.

code : les xxx_t

--------- Decodage de l'instruction -----------------

Maintenant qu'on connait de type d'instruction, il faut déterminer à quelle instruction
on a affaire précisément.

Pour les regops, c'est immédiat : les bits 24 à 21 de if_ir donnent directement l'opcode,
d'ou. (Pour les trans (Single Data Transfert), il suffit de lire les bits 20 et 22 qui donnent
respectivement le sens d'accès (lecture/écriture) et la taille de la données accédée (mot/octet)).

code : les xxx_i

La figure ... résume ce qu'il a dans DECOD pour l'instant.

[ Figure ]

-- Lecture des opérandes ---------------------

L'exécution d'une instruction nécéssite de récupérer la valeur de certains registres pour
effectuer une opération dessus (ce sera EXE qui la fera). DECOD doit se charger
de lire les registres nécéssaires depuis le banc de registres pour fournir leurs valeurs à EXE.

Pour cela, nous placerons 3 ports de lecture dans REG (3 car les instruction ont besoin de
connaître au maximum les valeurs de 3 registres). La lecture se fera au sein d'un même cycle d'horloge
car tout ce que fait DECOD doit se faire en un cycle.

Ensuite, DECOD doit déterminer quels registres lire à chaque fois.
Dans la documentation ARM, les registres à lire potentiellement sont Rd, Rn, Rm et Rs,
nous assignerons:
  - Le port de lecture 1 de REG     à Rn,
  - Le port 2 à Rm
  - Le port 3 à Rd et Rs
Aucune instruction ne lit Rd et Rs en même temps, donc il n'y aura pas de conflit sur le port 3.
Puis le numéro des registres Rn, Rm, Rd et Rs est données dans if_ir, encore selon la doc ARM :
  - Rd est donné dans les bits 15 à 12 (sauf pour le mult ou c'est de 19 à 15)
  - Rn -> if_ir(19:16) sauf pour les mult où c'est if_ir(15:12)
  - Rm -> if_ir(3:0)
  - Rs -> if_ir(11:8)
Il suffit de récupérer ces champs et de les donner en adresse à REG pour obtenir nos valeurs de registres :

code : radr

-- Envoi de l'opération à EXE ----------------

Une fois les opérandes lues, il s'agit de les envoyer vers EXE ainsi que les détails
sur l'opération à effectuer, c'est à dire les signaux :
  - alu_dest
  - op1
  - op2
  - alu_cmd
  - alu_cy
  - comp_op1
  - comp_op2
  - shift_lsl
  - shift_lsr
  - shift_asr
  - shift_ror
  - shift_rrx
  - shift_val

Nous nous concentrerons sur le cas des regops :

alu_dest sera Rd, c'est à dire if_ir(15:12).
op1 sera la valeur de Rn, (port 1 de REG)
op2 sera soit la valeur de Rm (port 2 de REG), soit un immediat (if_ir(7 downto 0) zero-extended)

Quant à alu_cmd, alu_cy, comp_op1 et comp_op2, leur valeur dépend de l'instruction en question,
la Figure ... détaille leurs valeurs.

[ Tableau ]

Enfin, il faut spécifier quel décalage appliquer à l'opérande 2.
Le type de décalage est donné par if_ir(6:5) mais dans le cas des rotations,
il faut distinguer ROR et RRX dans le cas if_ir(6:5) = "11" :
On a un ROR si l'opérande 2 est un immédiat ou si c'est un register mais que le shift amount n'est pas nul.

-------------------------------------------------------------------------------------------------------------------
bilan :
ameliorations :
 - FIFO a plusieurs cases
 - probleme D - E - M
   ldw R4, ...
   add R4, R10, R11
   add R4, R4, #1

ouverture :
 - Faudrait ensuite implementer
   les bypass
   la gestion de la vmem,
   les interruptions
   ...pour faire tourner Linux dessus

-------------------------------------------------------------------------------------------------------------------
Le moteur : PC qui s'incremente de 4 a chaque cycle

Decodage combinatoire
  Type de l'instruction
  Les regops
    op2 immediate
    op2 register
    shift immediate
    shift register
Lecture des operandes
  REG :
  Trois ports de lecture on-cycle
  Comment decider quels registres lire selon l'instruction actuelle
Gestion des dependances : Mecanisme d'invalidation des registres
  Le principe
  Invalidation dans DECOD
  Revalidation au writeback
Gestion des differents etats de DECOD : FSM
  DEC fera des choses differentes en fonction de
  si l'adresse PC est valide ou non,
  si on est en plein branchement et qu'on doit annuler les instruction qui suivent,
  si on est en plein transfert multiple,
  ou si on est tout simplement en etat "normal" et que les instructions defilent.
  => Pour gerer cela, la methode adequate est la MAE
  FETCH : L'adresse pointee par PC n'est pas valide, on attend qu'elle le soit.
  Ca arrive quand un branchement est dans EXE et que l'adresse de branchement
  est en train d'etre calculee, ou alors au demarrage de la machine.
  RUN : C'est l'etat "normal" de DEC, rien de special, les instructions arrivent,
  sont decodees puis envoyees dans EXE.

